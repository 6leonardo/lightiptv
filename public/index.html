<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Viewer</title>
    <link rel="stylesheet" href="styles.css">
    
</head>
<body>
    <div class="container">
        <h1>IPTV Viewer (threadfin tester)</h1>
        
        <div class="filter-section">
            <input type="text" id="searchInput" placeholder="üîç Cerca canali...">
        </div>

        <div class="stats" id="stats"></div>

        <div id="content">
            <div class="loading">Caricamento canali...</div>
        </div>
    </div>

    <!-- Video Overlay -->
    <div class="video-overlay" id="videoOverlay">
        <div class="video-container">
            <button class="close-button" id="closeButton">√ó</button>
            <div id="videoContent">
                <div style="display: flex; flex-direction: column; align-items: center; padding: 60px;">
                    <div class="spinner"></div>
                    <div class="loading-message">Preparazione stream...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- EPG Overlay -->
    <div class="epg-overlay" id="epgOverlay">
        <div class="epg-modal">
            <div class="epg-modal-header">
                <div class="epg-modal-title" id="epgModalTitle">EPG</div>
                <button class="epg-close-btn" id="epgCloseBtn">√ó</button>
            </div>
            <div class="epg-modal-content" id="epgModalContent">
                <div class="loading">Caricamento...</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        let allChannels = [];
        let currentSessionId = null;
        let heartbeatInterval = null;
        let epgData = null;
        let ffmpegLogVisible = false;
        let ffmpegLogElement = null;

        async function loadChannels() {
            try {
                const response = await fetch('/api/channels');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                allChannels = data.channels;
                
                // Load EPG data in background
                loadEPGBackground();
                
                displayChannels(allChannels);
                updateStats(allChannels.length, allChannels.length);
            } catch (error) {
                document.getElementById('content').innerHTML = `
                    <div class="error">
                        <h2>‚ùå Errore</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function displayChannels(channels) {
            const content = document.getElementById('content');
            
            if (channels.length === 0) {
                content.innerHTML = '<div class="loading">Nessun canale trovato</div>';
                return;
            }

            const grid = document.createElement('div');
            grid.className = 'channels-grid';

            channels.forEach(channel => {
                const card = document.createElement('div');
                card.className = 'channel-card';

                let logoElement;
                if (channel.logo) {
                    const proxyUrl = `/api/logo-proxy?url=${encodeURIComponent(channel.logo)}`;
                    logoElement = `<img src="${proxyUrl}" alt="${channel.name}" class="channel-logo" onerror="this.onerror=null; this.style.display='none'; this.parentElement.insertAdjacentHTML('afterbegin', '<div class=\\'channel-name\\'>${channel.name}</div>')">`;
                } else {
                    const initial = channel.name.charAt(0).toUpperCase();
                    logoElement = `<div class="channel-logo placeholder">${initial}</div>`;
                }

                // Get current program
                let epgInfoHtml = '';
                const hasEPG = epgData && channel.tvgId && epgData.epgData[channel.tvgId];
                
                if (hasEPG) {
                    const now = new Date();
                    const programs = epgData.epgData[channel.tvgId];
                    const currentProgram = programs.find(p => {
                        const start = new Date(p.start);
                        const stop = new Date(p.stop);
                        return now >= start && now <= stop;
                    });

                    if (currentProgram) {
                        const start = new Date(currentProgram.start);
                        const stop = new Date(currentProgram.stop);
                        const timeStr = `${start.getHours().toString().padStart(2, '0')}:${start.getMinutes().toString().padStart(2, '0')}-${stop.getHours().toString().padStart(2, '0')}:${stop.getMinutes().toString().padStart(2, '0')}`;
                        epgInfoHtml = `
                            <div class="epg-info" onclick="event.stopPropagation(); showChannelEPG('${channel.tvgId}', '${channel.name.replace(/'/g, "\\'")}')">
                                <div class="epg-info-time">${timeStr}</div>
                                <div class="epg-info-title">${currentProgram.title}</div>
                            </div>
                        `;
                    } else {
                        epgInfoHtml = `
                            <div class="no-epg-placeholder" onclick="event.stopPropagation(); showChannelEPG('${channel.tvgId}', '${channel.name.replace(/'/g, "\\'")}')">
                                üìã Visualizza EPG
                            </div>
                        `;
                    }
                }

                card.innerHTML = `
                    ${channel.isStreaming ? '<div class="streaming-indicator"></div>' : ''}
                    ${logoElement}
                    ${epgInfoHtml}
                    ${channel.group ? `<div class="channel-group">${channel.group}</div>` : ''}
                `;

                // Click on card (but not on EPG area) = play
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.epg-info') && !e.target.closest('.no-epg-placeholder')) {
                        startStream(channel);
                    }
                });

                grid.appendChild(card);
            });

            content.innerHTML = '';
            content.appendChild(grid);
        }

        function showChannelEPG(tvgId, channelName) {
            if (!tvgId || !epgData || !epgData.epgData[tvgId]) {
                alert('Nessun EPG disponibile per questo canale');
                return;
            }

            const overlay = document.getElementById('epgOverlay');
            const modalTitle = document.getElementById('epgModalTitle');
            const modalContent = document.getElementById('epgModalContent');

            modalTitle.textContent = `EPG - ${channelName}`;

            const programs = epgData.epgData[tvgId];
            const now = new Date();

            let html = '';
            programs.forEach(program => {
                const startTime = new Date(program.start);
                const endTime = new Date(program.stop);
                
                // Skip past programs - show only current and future
                if (now > endTime) {
                    return;
                }
                
                let programClass = 'epg-program';
                if (now >= startTime && now <= endTime) {
                    programClass += ' current';
                }

                const timeStr = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')} - ${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;

                html += `<div class="${programClass}">`;
                html += `<div class="epg-time">${timeStr}</div>`;
                html += `<div class="epg-title">${program.title || 'Nessun titolo'}</div>`;
                if (program.desc) {
                    html += `<div class="epg-desc">${program.desc}</div>`;
                }
                if (program.category) {
                    const cat = String(program.category).trim();
                    if (cat) {
                        html += `<span class="epg-category">${cat}</span>`;
                    }
                }
                html += `</div>`;
            });

            modalContent.innerHTML = html;
            overlay.classList.add('active');
        }

        function closeEPGOverlay() {
            document.getElementById('epgOverlay').classList.remove('active');
        }

        async function startStream(channel) {
            // Show overlay with spinner
            const overlay = document.getElementById('videoOverlay');
            const videoContent = document.getElementById('videoContent');
            overlay.classList.add('active');
            
            videoContent.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; padding: 60px;">
                    <div class="spinner"></div>
                    <div class="loading-message">Avvio stream ${channel.name}...</div>
                </div>
            `;

            try {
                // Start stream on backend
                const response = await fetch('/api/stream/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        streamUrl: channel.stream,
                        channelName: channel.name
                    })
                });

                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                currentSessionId = data.sessionId;
                
                // Poll for stream readiness
                await pollStreamStatus(data.sessionId, data.m3u8Url, channel.name);
                
            } catch (error) {
                console.error('Error starting stream:', error);
                videoContent.innerHTML = `
                    <div style="color: white; padding: 60px; text-align: center;">
                        <h2>‚ùå Errore</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        async function pollStreamStatus(sessionId, m3u8Url, channelName) {
            const maxAttempts = 30; // 30 seconds max
            let attempts = 0;
            const videoContent = document.getElementById('videoContent');

            const checkStatus = async () => {
                try {
                    const response = await fetch(`/api/stream/status/${sessionId}`);
                    const status = await response.json();

                    // Update progress bar
                    const progress = status.progress || 0;
                    
                    videoContent.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; padding: 60px 40px; width: 100%; max-width: 900px;">
                            <div class="loading-message">Preparazione stream ${channelName}...</div>
                            <div style="width: 100%; margin-top: 20px;">
                                <div style="background: rgba(255,255,255,0.2); border-radius: 10px; height: 30px; overflow: hidden;">
                                    <div style="background: linear-gradient(90deg, #4caf50, #8bc34a); height: 100%; width: ${progress}%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                        ${progress}%
                                    </div>
                                </div>
                                <div style="color: #aaa; margin-top: 10px; text-align: center; font-size: 0.9em;">
                                    ${status.tsCount || 0} segmenti / ${status.elapsedTime || 0}s
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Update FFmpeg log
                    updateFFmpegLog(status.ffmpegCommand || '', status.ffmpegOutput || []);

                    if (status.ready) {
                        // Stream is ready, keep FFmpeg log visible and load video player
                        loadVideoPlayer(m3u8Url, channelName);
                        return true;
                    } else if (status.error) {
                        throw new Error(status.error);
                    }

                    attempts++;
                    if (attempts >= maxAttempts) {
                        throw new Error('Timeout: stream non pronto');
                    }

                    // Check again in 1 second
                    setTimeout(checkStatus, 1000);
                } catch (error) {
                    console.error('Error polling stream:', error);
                    document.getElementById('videoContent').innerHTML = `
                        <div style="color: white; padding: 60px; text-align: center;">
                            <h2>‚ùå Errore</h2>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            };

            checkStatus();
        }

        function loadVideoPlayer(m3u8Url, channelName) {
            const videoContent = document.getElementById('videoContent');
            
            videoContent.innerHTML = `
                <video id="videoPlayer" class="video-player" controls autoplay></video>
                <div style="color: white; padding: 15px; background: rgba(0,0,0,0.8);">
                    <h3>${channelName}</h3>
                </div>
            `;

            const video = document.getElementById('videoPlayer');

            if (Hls.isSupported()) {
                const hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                });
                
                hls.loadSource(m3u8Url);
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    video.play();
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS error:', data);
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                hls.destroy();
                                break;
                        }
                    }
                });

                // Store hls instance for cleanup
                video.hlsInstance = hls;
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                video.src = m3u8Url;
                video.addEventListener('loadedmetadata', () => {
                    video.play();
                });
            }

            // Start heartbeat to keep stream alive
            startHeartbeat();
        }

        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            heartbeatInterval = setInterval(() => {
                if (currentSessionId) {
                    fetch(`/api/stream/heartbeat/${currentSessionId}`, {
                        method: 'POST'
                    }).catch(err => console.error('Heartbeat error:', err));
                }
            }, 10000); // Every 10 seconds
        }

        function stopStream() {
            // Stop heartbeat
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }

            // Destroy HLS instance
            const video = document.getElementById('videoPlayer');
            if (video && video.hlsInstance) {
                video.hlsInstance.destroy();
            }

            // Stop stream on backend
            if (currentSessionId) {
                fetch(`/api/stream/stop/${currentSessionId}`, {
                    method: 'POST'
                }).catch(err => console.error('Error stopping stream:', err));
                
                currentSessionId = null;
            }

            // Hide overlay
            document.getElementById('videoOverlay').classList.remove('active');
        }

        // Close button handlers
        document.getElementById('closeButton').addEventListener('click', stopStream);
        document.getElementById('epgCloseBtn').addEventListener('click', closeEPGOverlay);

        function updateStats(displayed, total) {
            const stats = document.getElementById('stats');
            stats.textContent = `Visualizzati ${displayed} di ${total} canali`;
        }

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const filtered = allChannels.filter(channel => 
                channel.name.toLowerCase().includes(searchTerm) ||
                channel.group.toLowerCase().includes(searchTerm)
            );
            displayChannels(filtered);
            updateStats(filtered.length, allChannels.length);
        });

        // EPG functionality
        async function loadEPGBackground() {
            try {
                const response = await fetch('/api/epg');
                const data = await response.json();
                
                if (!data.error) {
                    epgData = data;
                    // Refresh channel display to show current programs
                    displayChannels(allChannels);
                }
            } catch (error) {
                console.error('Error loading EPG in background:', error);
            }
        }

        // FFmpeg log management
        function updateFFmpegLog(command, output) {
            if (!ffmpegLogElement) {
                createFFmpegLog();
            }
            
            const fullText = `$ ${command}\n\n${output.join('\n')}`;
            const truncated = fullText.length > 5000 ? fullText.slice(-5000) : fullText;
            
            ffmpegLogElement.textContent = truncated;
            
            // Auto-scroll to bottom if visible
            if (ffmpegLogVisible) {
                ffmpegLogElement.scrollTop = ffmpegLogElement.scrollHeight;
            }
        }
        
        function createFFmpegLog() {
            const logDiv = document.createElement('div');
            logDiv.id = 'ffmpegLog';
            logDiv.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 250px;
                background: rgba(0, 0, 0, 0.95);
                color: #0f0;
                font-family: monospace;
                font-size: 11px;
                padding: 15px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
                line-height: 1.3;
                z-index: 10000;
                border-top: 2px solid #4caf50;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
                display: ${ffmpegLogVisible ? 'block' : 'none'};
            `;
            document.body.appendChild(logDiv);
            ffmpegLogElement = logDiv;
        }
        
        function toggleFFmpegLog() {
            ffmpegLogVisible = !ffmpegLogVisible;
            if (ffmpegLogElement) {
                ffmpegLogElement.style.display = ffmpegLogVisible ? 'block' : 'none';
                if (ffmpegLogVisible) {
                    ffmpegLogElement.scrollTop = ffmpegLogElement.scrollHeight;
                }
            }
        }
        
        // Keyboard shortcut: H to toggle FFmpeg log
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                e.preventDefault();
                toggleFFmpegLog();
            }
        });

        // Load channels on page load
        loadChannels();
    </script>
</body>
</html>
